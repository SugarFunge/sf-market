/* MIT License - Copyright (c) Vertex Studio. */


!function(e){"use strict";class r extends Error{constructor({error:e,extensions:t,...n}){super(e),Object.assign(this,n),Object.assign(this,t),Error.captureStackTrace&&Error.captureStackTrace(this,r)}}const t=(e,r)=>e.concat(r.errors?r.errors:[r]);e.buildClient=e=>({debug:n,address:a,log:s,...o})=>{s||(s=n?console.debug:()=>{});const c=new Map,i=new Map,d=()=>{const e=Math.random().toString(36).slice(2);return c.has(e)?d():e},l=e=>{i.clear();for(const[r,{reject:t,noCleanup:n}]of c)n||g.delete(r),c.delete(r),t(e);return e},u=(e,r={})=>{r.duration=Date.now()-e.start,r.size=e.size,r.name=e.query,r.id=e.id,s("query",r),c.delete(e.id),e.noCleanup||g.delete(e.id)},p=(e,a,o)=>{if(!e)return s("missing-handler",{id:o,type:"error"});a.errors&&(a.errors=a.errors.reduce(t,[]),Object.assign(a,a.errors[0])),u(e,{payload:a,type:"error"}),c.delete(o);const i=new r(a);return n&&(i.trace=e.trace.stack),e.reject(i)},y=(e,t)=>l(new r({error:`WebSocket connection ${t}`,event:e}));let h=e(a),g=new Map;const w=(e,r,t,a)=>new Promise((async(o,i)=>{await k;const d={id:e,resolve:o,reject:i,size:0,query:t,start:Date.now(),noCleanup:a};n&&(d.trace=Error("hasuraClient.exec error")),c.set(e,d),g.set(e,{payload:r,name:t}),s("start",{id:e,payload:r}),h.send(`{"type":"start","id":"${e}","payload":${r}}`)})),m=(e,r)=>w(d(),e,r),b=(e,r,t)=>{const n=d();return i.set(n,e),{execution:w(n,r,t,!0),unsubscribe:()=>{i.delete(n),g.delete(n),s("stop",{id:n}),h.send(`{"type":"stop","id":"${n}"}`)}}},f=()=>new Promise(((e,t)=>{h.on("error",(e=>t(y(e,"failed")))),h.on("close",(e=>t(y(e,"close")))),h.on("message",(n=>((e,t,n)=>{if('{"type":"ka"}'===e)return;const{type:a,payload:o,id:d}=JSON.parse(e),y=c.get(d);switch(y&&(y.size+=e.length),s("raw",e),a){case"connection_ack":return t(o);case"connection_error":return n(l(new r({error:o})));case"data":if(o.errors)return p(y,o,d);const e=i.get(d);return e?(e(o.data),void(y&&(u(y,{type:a,payload:o}),y.resolve()))):y?y.payload=o:s("missing-handler",{id:d,type:"error"});case"error":return p(y,o,d);case"complete":if(!y)return;return u(y,{type:a,payload:o}),y.resolve(y.payload&&y.payload.data)}})(n,e,t)))})).then((()=>S=!0));let S,k=f();const v=async({adminSecret:r,token:t,role:n,headers:s})=>{const o=g,c=S;c&&(h.close(),h=e(a),k=f(),g=new Map,S=!1),h.readyState||await new Promise((e=>h.on("open",e)));const i={headers:r?{"x-hasura-admin-secret":r,...s}:{Authorization:`Bearer ${t}`,...s}};return n&&(i.headers["x-hasura-role"]=n),h.send(JSON.stringify({type:"connection_init",payload:i})),c&&k.then((()=>{for(const[e,{payload:r,name:t}]of o)w(e,r,t)})),k};return(o.adminSecret||o.token)&&v(o),{ws:h,connect:v,connection:k,runFromString:m,subscribeFromString:b,run:(e,r)=>m(JSON.stringify({query:e,variables:r})),subscribe:(e,r,t)=>b(e,JSON.stringify({query:r,variables:t}))}}}(this.hasuraWs=this.hasuraWs||{});
